#  **[ 3777 : Computer Transformation ]**


🔗[문제링크](https://www.acmicpc.net/problem/3777)


###  **[통과 시의 스펙]**
![Image](https://github.com/user-attachments/assets/c21feabc-2a66-4cad-aff2-51f7aef9acb7)
 **_무려 3등!!!!_**

### **[해결 과정]**

- 문제해석
처음에 컴퓨터에 입력된 1은 한 자릿수로 구성된 시퀀스 sequence 이다.
연속적인 시간의 흐름에 따라 컴퓨터는 숫자 0을 시퀀스 1 0으로, 숫자 1을 시퀀스 0 1로   변환한다.
첫 번째 시간 단계 후에, 시퀀스 0 1이 얻어지고, 두 번째 단계 이후에, 시퀀스 1 0 0 1이 얻어지고, 세 번째 단계 이후에, 시퀀스  0 1 1 0 1 0 0 1 이 얻어지며 그 후 계속....
n단계 이후의 순서에서 몇 쌍의 0이 나타날 것인가?
입력:  0 보다 큰1000 이하의 자연수 n
출력: 입력 n에 대해 n단계 이후 시퀀스에 나타날 연속된 0 의 pair 수를 인쇄



- 문제단순화
1. 주어진 input을 2의 지수로 넣고 계산했을 때, 나온 값은 칸의 수(숫자의 개수)이다.
2. 단순 치환으로 접근하여 매크로를 쓰려고 하던 중 규칙을 발견 하였다.
3. 0이 연속되는 경우는 이전단계에서 0 1이 오는 경우 뿐이다.
4. 0 1 이 생기는 조건은 이전단계에 1이 있는 경우와 0 0 이 있는 경우 뿐이다.
5. 즉, 결과적으로 사용되는 패턴은 1001 와  0110 뿐이다.


- 풀이 
1. n번째 시퀀스 = (n-1)번째 시퀀스의 거울모드 + (n-1)번째 시퀀스  라는 것을 확인.
2. 짝수번째 2n+2의 경우 2n-번째 까지의 누적 합 +1 이라는 것을 확인.
3. 2n+1의 경우 2n번째 까지의 누적합 이라는 것을 확인 하였습니다.
4. 1번째의 경우는 0개 , 2번째의 경우는 1개로 규칙에 포함시키지 않고 초기값을 대입. (피보나치 수열에서 착안)



### **[느낀 점]**
예제가 1개 뿐이어서 이해하는데 시간이 조금 걸렸드아...ㅜ _~~넘나 불친절한것...ㅜ~~_
데이터의 크기 (2의 1000승)가 문제가 된다는 생각은 하지도 못하고 로직은 일찍이 완성하였음에도, 오답의 원인을 찾지 못하였다... _~~젠장.....~~_
컴퓨터 개론 수업 좀 잘 들을 껄... 



###  **[리마인드]** 

- char* 와 char[]은 문자열 배열을 입력할 수 있는 자료형이며, 크기는 1byte 이다.
  char str[] = "Test";  //포인터 상수.= str의 주소값은 상수로 지정되어 주소값 변경이 불가능하다.
  const char * str = "Test"; //상수 포인터 const char *는 값을 받을 때 문자열  상수의 주소를 받게 된다.

- 2의 64승(8바이트)는 대략 천팔백경,20자리이다.
  2의 32승은 대략 사십억,10자리 이다. 

- 배열을 이용한 기존 데이터 형을 초과하는 크기의 수 출력/연산을 공부하게 되었다.
  C나 C++에서는 거의 가장 큰 정수 자료형인 long long의 경우에도 9 × 10^18 정도 까지 밖에 표현하지 못한다.
  따라서 그보다 큰 수를 더하기 위해서는 문자열로 정수를 입력 받고, 따라서 그보다 큰 수를 연산/출력 하기 위해선, 문자열로 정수를 입력 받아 처리하였다.

- 컴퓨터 CPU의 데이터를 저장하는 순서에 따라 디버깅 과정에서 메모리의 값을 읽는 방식이 달라지는데,
  저장할 때 상위 바이트. 즉, 큰 쪽을 먼저 저장하는 것을 빅 엔디안(Big Endian), 저장할 때 하위 바이트. 즉, 작은 쪽을 먼저 저장하는 것을 리틀 엔디안(Little Endian)이라고 한다.
