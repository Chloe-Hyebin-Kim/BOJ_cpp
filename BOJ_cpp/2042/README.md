#  **[ 2042 : 구간 합 구하기 ]**




🔗[문제링크](https://www.acmicpc.net/problem/2042)


###  **[통과 시의 스펙]**
![image](https://github.com/user-attachments/assets/50563bdf-2c67-4fb6-b727-9b93e4bc2561)


### **[해결 과정]**

- 문제해석


- 문제단순화



- 풀이 
1. 가장 먼저 세그먼트 트리의 배열 크기를 구한다.
     1) 입력 배열개수가 n으로 가정 ```vector<int> arrInput (n);```
     2) 2^k 가 n 보다 크거나 같아지는 가장 작은 k를 구한다. K는 세그먼트 트리 높이이다. ```int k = ceil(log2(n));```
     3) 리프노드 시작 인덱스를 구한다. ```int leafStart = 1 << k;```
     4) 시작 인덱스 * 2를 하여 세그먼트 트리의 배열 크기를 구한다. ```int segSize = 2 * leafStart;```
     5) 다만, 편의를 위해  4n로 할때도 있음 ```arrSegmentTree = [0] * (len(arrInput)*4);```
2. 세그먼트 트리의 초기화
     - 세그트리의 리프노드(맨 밑바닥 노드)에 그대로~ 입력받은 배열을 넣는다!
     - arrSegmentTree[2^k]=arrInput[0]   : 시작
     - arrSegmentTree[(2^k)+n]=arrInput[n-1]   : 끝
3. 질의를 구하는 과정
     1) 부모 노드로 이동하지 않고 그 자체를 쓰는 경우
        - 질의 범위의 시작노드가 홀수일 때```startIdx % 2 == 1 ```,
        - 질의 범위의 끝노드가 짝수일 때```endIdx % 2 == 0``` 
     2) 위의 경우가 아니면 부모로 이동!!!
        startIdx = (startIdx+1) / 2
        endIdx = (endIdx-1) / 2
     3) 시작노드가 끝노드와 크거나 같아지면 끝! (크로스!)
4.값 Update 함수 작성 (필요시)
  이동할 인덱스 =  현재 인덱스 / 2 


###  **[리마인드]** 
1. 현재 구간이 완전히 포함 (left <= start && end <= right) → 해당 노드 값을 반환 (3-1번에 해당)
2. 현재 구간이 일부만 겹치면 → 왼쪽 자식과 오른쪽 자식으로 쪼개서 탐색하고,각 결과를 합산하여 반환.(3-2번에 해당)
3. 현재 구간이 완전히 겹치지 않음 (right < start || end < left) → 쿼리에 영향을 주지 않는 값을 반환 (3-3번에 해당)
   예)최소를 구할때는 제시된 범위를 넘는 아주큰 수를, 곱하기나누기는 항등원인 1을, 더하기빼기는 항등원인 0을!!!
