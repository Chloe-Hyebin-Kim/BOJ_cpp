#  **[ 9203 : 호텔 예약 ]**


🔗[문제링크](https://www.acmicpc.net/problem/9203)


###  **[통과 시의 스펙]**
![Image](https://github.com/user-attachments/assets/06b12163-4b7f-4a70-b27c-a8437ef1948b)


### **[해결 과정]**

- 문제단순화
1. 데이터 입력에 상당히 많은 정보가 패턴의 형태로 들어오기 때문에 input 정보를 단순화 하는 작업이 필요. _~~ㄹㅇ 노가다~~_ 
2. 시간날짜 를 컨버팅 해야 함. (주어진 단위 중 가장 작은 단위가 분(minute)이기 때문에 분을 기준으로 환산)
3. 2월에 28일까지만 있다면 윤년이 아님을 의미!!!


- 풀이 
1.  2016년은 윤년이다. 이 부분을 먼저 계산하여 시간날짜 를 컨버팅 하는 함수를 만들었다.
2. 2월에 28일까지만 있다면 윤년이 아니다.
3. 입실 기간을 분(minute)으로 환산하여 컨버팅 하였다. 
4. 입퇴실 시간을 짝으로 배열을 만들고 정렬함.
5. 데이터 중복사용 및 오름차순 정렬 삽입!



### **[느낀 점]**
- 데이터의 중복사용을 위해, 그리고 데이터의 효율적 관리를 위해 중복 키를 허용하는 연관 컨테이너 multiset을 사용.
  근데 이진 탐색을 사용하므로 검색 속도가 생각보다 느리다... 이게 최선일까? ...
  

###  **[리마인드]** 
- Iterator를 활용하여 set의 원소에 접근할 수 있다.
  set.begin() : set의 첫번째 원소를 가리키는 iterator 리턴
  set.end() : set의 마지막 원소 다음을 가리키는 iterator 리턴 (마지막 원소 아님!!)

- multiset은 C++ STL(Standard Template Library)의 연관 컨테이너 중 하나로 중복된 값을 저장할 수 있다.
  multiset은 #include <set> 헤더 파일을 포함해야 한다.
  
- 각 요소의 키 값이 변경되지 않는다. 따라서 변경을 원한다면 이전 값을 삭제하고 새 값을 삽입해야 한다.
  각 요소의 키 값을 기준으로 요소는 자동으로 정렬된다.
  내림차순 정렬 set 생성시 기본적으로 오름차순(less)정렬이 되지만, greater<int> 울 사용하면 내림차순 정렬이 된다.   (예. multiset<int, greater<int>> mts; ) 
  
- multiset은 요소를 삽입하거나 삭제할 때, 기존 요소의 위치를 변경할 수 있으므로, 반복자 유효성을 유지하는 것이 어려울 수 있다.
  
- 각 요소를 검색할 때, 이진 탐색을 사용하므로 검색 속도가 느릴 수 있다.
  
- size : 원소의 개수 반환
- begin : 첫 번째 원소의 반복자를 반환
- end : 마지막 원소 다음의 반복자를 반환
- erase :  특정 원소나 지정한 범위의 원소들을 삭제
- find : 특정 원소의 반복자를 반환. 존재하지 않는 경우 마지막 원소 다음의 반복자를 반환
- clear : 컨테이너 내우의 모든 원소들을 삭제
- empty : 컨테이너가 비어있다면 true를 반환.
- insert : 원소 삽입
- lower_bound : 지정한 원소 이상의 첫번째 위치의 반복자를 반환
- upper_bound : 지정한 원소보다 큰 첫번째 위치의 반복자를 반환
- count : 원소가 있으면 1, 아니면 0을 반환
- rbegin : 역방향으로 첫 번째 원소의 반복자를 반환
- rend : 역방향으로 마지막 원소 다음의 반복자를 반환
