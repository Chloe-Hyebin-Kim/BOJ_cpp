#  **[ 10250 : ACM 호텔]

🔗[문제링크](https://www.acmicpc.net/problem/10250)



###  **[통과 시의 스펙]**
![image](https://github.com/user-attachments/assets/1d9760dd-daf5-44fe-909b-75a5e2431447)



### **[해결 과정]**

- 문제단순화
  1. 걍... 왼쪽 세로줄을 오른쪽으로, 아래부터 배치하면 됨.
  2. 딱 나눠 떨어지는 경우(방문자 등수 N 이 층 H의 배수인 경우)는 다음 호수 라인으로 넘어가지 않고 맨 꼭대기 층 배치
  3. 네이밍 규칙 유의(아파트 호수 처럼 11츧의 8호는 1108이고 11층의 12호는 1112라는 사실을 주의!)

   
- 풀이 
  1. 방문객 등수(N)을 층(H)으로 나눈 몫은 가로(왼쪽->오른쪽)진행되는 방 호 수랑 관련
     객실 호 수 = (N / H) + 1;
  2. 방문객 등수(N)을 층(H)으로 나눈 나머지는 세로(아래-> 위)진행되는 방 층 수와 관련
     객실 층 수 = (N % H);
     
  3. 굳이 공식화를 하자면,,,분기를 나누는 값 만들어 볼수 있음. _~~근데 이렇게 안해도 그냥 직관적으로 가능..하지 않나..??~~_
     
     딱나눠 떨어짐 때는 꼭대기층이라 N = H; 이고 객싷호수는 무조건 1호임.
     약간...  층이 9층인 호텔이라 하면...주판 느낌...?

    
  
     1. 나머지가 0이 아닐 때
        ```
        3
        6 12 10
        30 50 72
        6 3 4
        //402
        //1203
        //401
        ```
     2. 나머지가 0일 때
        ```
        5
        6 6 12
        3 30 3
        3 10 30
        5 1 5
        6 10 3
        //602
        //301
        //310
        //501
        //301
        ```
     3. H = N
        ```
        2
        6 6 6
        5 1 5
        //601
        //501
        ```
     5. H > N
        ```
        1
        6 10 3
        //301
        ```

4. 네이밍 규칙: 객실 호 수가 10보다 작은 경우 층과 호수 사이에 0을 붙여줌



###  **[리마인드]** 
1. itoa는 Visual Studio에서 "임의로 stdlib.h에 입력한 함수다!"
   따라서 itoa는 비표준이므로, 어떤 환경에서도 동작을 보장할 수 없다.  (atoi는 표준이기 때문에 어떤 환경에서도 동작)
   그래서 숫자로 입력받아 to_string으로 바꿔서 네이밍 해결.

다음은 itoa를 사용하기위한 별도로 함수이다. 다른 타입의 역순 전환도 해당됨!

```
char * ftoa(float f)
{
  char buf[256];//임의로 편리하게 작성한 것이므로 충분한 버퍼 크기를 정해줘야 한다!
  char *buf;
  sprintf(buf, "%f", f);
  return buf;
}

char * itoa(int i)
{
  char buf[11];//임의로 편리하게 작성한 것이므로 충분한 버퍼 크기를 정해줘야 한다!
  char *buf;
  sprintf(buf, "%d", i);
  return buf;
}
```


